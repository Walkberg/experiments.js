import { ConnectionBase, ConnectionId, NodeBase, NodeId } from "./graph-editor";

export type PortId = string;

export class Socket {
  constructor(public id: string) {}
}

export class Port<S extends Socket> {
  id: PortId;

  constructor(
    public socket: S,
    public label?: string,
    public multipleConnections?: boolean
  ) {
    this.id = getUID();
  }
}

export class Input<S extends Socket> extends Port<S> {
  control: Control | null = null;

  showControl = true;

  constructor(socket: S, label?: string, multipleConnections?: boolean) {
    super(socket, label, multipleConnections);
  }

  addControl(control: Control): void {
    this.control = control;
  }

  removeControl(): void {
    this.control = null;
  }
}

export class Output<S extends Socket> extends Port<S> {
  constructor(socket: S, label?: string, multipleConnections?: boolean) {
    super(socket, label, multipleConnections);
  }
}

export class Control {
  id: string;

  constructor() {
    this.id = getUID();
  }
}

export class Node<
  Inputs extends { [key in string]?: Socket } = { [key in string]?: Socket },
  Outputs extends { [key in string]?: Socket } = { [key in string]?: Socket },
  Controls extends { [key in string]?: Control } = { [key in string]?: Control }
> implements NodeBase
{
  /**
   * Node id, unique string generated by `getUID` function
   */
  id: NodeBase["id"];
  /**
   * Node inputs
   */
  inputs: Map<keyof Inputs, Input<Exclude<Inputs[keyof Inputs], undefined>>> =
    new Map();
  /**
   * Node outputs
   */
  outputs: Map<
    keyof Outputs,
    Output<Exclude<Outputs[keyof Outputs], undefined>>
  > = new Map();
  /**
   * Node controls
   */
  controls: Controls = {} as Controls;
  /**
   * Whether the node is selected. Default is `false`
   */
  selected?: boolean;

  constructor(public label: string) {
    this.id = getUID();
  }

  hasInput<K extends keyof Inputs>(key: K) {
    return this.inputs.has(key);
  }

  addInput<K extends keyof Inputs>(
    key: K,
    input: Input<Exclude<Inputs[K], undefined>>
  ) {
    if (this.hasInput(key))
      throw new Error(`input with key '${String(key)}' already added`);

    this.inputs.set(key, input);
  }

  removeInput(key: keyof Inputs) {
    this.inputs.delete(key);
  }

  hasOutput<K extends keyof Outputs>(key: K) {
    return this.outputs.has(key);
  }

  addOutput<K extends keyof Outputs>(
    key: K,
    output: Output<Exclude<Outputs[K], undefined>>
  ) {
    if (this.hasOutput(key))
      throw new Error(`output with key '${String(key)}' already added`);

    this.outputs.set(key, output);
  }

  removeOutput(key: keyof Outputs) {
    this.outputs.delete(key);
  }

  hasControl<K extends keyof Controls>(key: K) {
    return Object.prototype.hasOwnProperty.call(this.controls, key);
  }

  addControl<K extends keyof Controls>(key: K, control: Controls[K]) {
    if (this.hasControl(key))
      throw new Error(`control with key '${String(key)}' already added`);

    Object.defineProperty(this.controls, key, {
      value: control,
      enumerable: true,
      configurable: true,
    });
  }

  removeControl(key: keyof Controls) {
    delete this.controls[key];
  }
}

export class Connection<Source extends Node, Target extends Node>
  implements ConnectionBase
{
  id: ConnectionId;
  source: NodeId;
  target: NodeId;

  constructor(source: Source, target: Target) {
    this.id = getUID();

    this.id = getUID();
    this.source = source.id;
    this.target = target.id;
  }
}

function getUID(): string {
  return (
    Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15)
  );
}
